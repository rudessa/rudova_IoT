# LedCascade - Управление светодиодами с разными периодами мигания

## Аннотация

Данная работа представляет решение задачи управления пятью светодиодами с различными периодами мигания на микроконтроллере AVR (Arduino Uno). Реализация использует аппаратный таймер Timer1 в режиме CTC с прерываниями для обеспечения точного временного контроля без использования функций задержки.

## 1. Постановка задачи

### 1.1 Цель работы

Разработать программу для управления пятью светодиодами, подключёнными к портам PB0-PB4 микроконтроллера, где каждый светодиод мигает с индивидуальным периодом.

### 1.2 Ограничения

- Запрещено использование функций `delay()` и `millis()`
- Все операции с портами через регистры (DDRx, PORTx, PINx)
- Использование одного таймера для всех светодиодов
- Периоды определяются как кратные базовому интервалу
- Применение побитовых операций для работы с регистрами
- Точность таймера: 1/16000000 секунды (62.5 нс)

### 1.3 Технические требования

**Периоды мигания:**

- LED1 (PB0): 1 базовый интервал
- LED2 (PB1): 2 базовых интервала
- LED3 (PB2): 3 базовых интервала
- LED4 (PB3): 4 базовых интервала
- LED5 (PB4): 5 базовых интервалов

**Базовый интервал:** 100 мс (0.1 секунды)

## 2. Теоретические основы

### 2.1 Таймеры микроконтроллера AVR

Микроконтроллер ATmega328P (Arduino Uno) содержит три таймера:

- **Timer0**: 8-битный (используется системой Arduino)
- **Timer1**: 16-битный (используется в данном проекте)
- **Timer2**: 8-битный

Для точного управления временными интервалами выбран 16-битный Timer1, обеспечивающий диапазон от 0 до 65535.

### 2.2 Режим CTC (Clear Timer on Compare)

В режиме CTC счётчик таймера автоматически сбрасывается при достижении значения, записанного в регистр сравнения OCR1A. Это позволяет создавать точные периодические прерывания.

**Формула расчёта периода:**

```
T = (OCR1A + 1) × Prescaler / F_CPU
```

Где:

- T — период прерывания (секунды)
- OCR1A — значение регистра сравнения
- Prescaler — коэффициент предделителя (1, 8, 64, 256, 1024)
- F_CPU — частота процессора (16 МГц)

### 2.3 Расчёт параметров таймера

**Дано:**

- F_CPU = 16 000 000 Гц
- Желаемый период: T = 0.1 с (100 мс)
- Выбранный prescaler: 256

**Расчёт OCR1A:**

```
OCR1A = (F_CPU × T / Prescaler) - 1
OCR1A = (16000000 × 0.1 / 256) - 1
OCR1A = (1600000 / 256) - 1
OCR1A = 6250 - 1 = 6249
```

**Проверка:**

```
T = (6249 + 1) × 256 / 16000000 = 6250 × 256 / 16000000 = 0.1 с ✓
```

## 3. Архитектура решения

### 3.1 Структурная схема

```
┌─────────────────────────────────────┐
│         Микроконтроллер             │
│                                     │
│  ┌──────────────┐                   │
│  │   Timer1     │                   │
│  │  (режим CTC) │                   │
│  │              │                   │
│  │  Prescaler   │                   │
│  │    256       │                   │
│  │              │                   │
│  │  OCR1A=6249  │                   │
│  └──────┬───────┘                   │
│         │                           │
│         ▼                           │
│  ┌──────────────┐                   │
│  │  Прерывание  │                   │
│  │ каждые 100мс │                   │
│  └──────┬───────┘                   │
│         │                           │
│         ▼                           │
│  ┌──────────────────┐               │
│  │  ISR(TIMER1_     │               │
│  │  COMPA_vect)     │               │
│  │                  │               │
│  │ • counter1++     │               │
│  │ • counter2++     │               │
│  │ • counter3++     │               │
│  │ • counter4++     │               │
│  │ • counter5++     │               │
│  │                  │               │
│  │ Проверка и       │               │
│  │ переключение LED │               │
│  └──────┬───────────┘               │
│         │                           │
│         ▼                           │
│  ┌──────────────┐                   │
│  │   PORTB      │                   │
│  └──────┬───────┘                   │
└─────────┼───────────────────────────┘
          │
          ├── PB0 → LED1 (период: 1×100мс = 100мс)
          ├── PB1 → LED2 (период: 2×100мс = 200мс)
          ├── PB2 → LED3 (период: 3×100мс = 300мс)
          ├── PB3 → LED4 (период: 4×100мс = 400мс)
          └── PB4 → LED5 (период: 5×100мс = 500мс)
```

### 3.2 Алгоритм работы

**Инициализация:**

1. Настройка пинов PB0-PB4 как выходов через регистр DDRB
2. Установка начального состояния светодиодов (все включены)
3. Конфигурация Timer1 в режиме CTC
4. Установка предделителя 256
5. Запись значения 6249 в OCR1A
6. Разрешение прерывания TIMER1_COMPA

**Работа прерывания (каждые 100 мс):**

1. Инкремент всех счётчиков (counter1-counter5)
2. Для каждого светодиода:
   - Если `counter < PERIOD`: включить LED (HIGH)
   - Если `counter >= PERIOD и < PERIOD*2`: выключить LED (LOW)
   - Если `counter >= PERIOD*2`: сбросить счётчик в 0

**Пример работы LED3 (период = 3):**

- Интервалы 0-2: LED включен (counter = 0,1,2)
- Интервалы 3-5: LED выключен (counter = 3,4,5)
- Интервал 6: сброс счётчика, цикл повторяется

### 3.3 Временная диаграмма работы

```
Время (мс): 0   100  200  300  400  500  600  700  800  900  1000
           ─┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼─→
            │    │    │    │    │    │    │    │    │    │    │
LED1 (100): ▀▀▀▀▄▄▄▄▀▀▀▀▄▄▄▄▀▀▀▀▄▄▄▄▀▀▀▀▄▄▄▄▀▀▀▀▄▄▄▄▀▀▀▀▄▄▄▄▀▀▀▀▄
            └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘ └─┬─┘
             ON  OFF ON  OFF ON  OFF ON  OFF ON  OFF ON  OFF

LED2 (200): ▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄
            └───────┬───────┘ └───────┬───────┘ └───────┬───────┘
                   ON      OFF       ON      OFF

LED3 (300): ▀▀▀▀▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄▄▄▄▄▀▀▀▀▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄▄▄▄▄▀
            └───────────┬───────────┘ └───────────┬───────────┘
                       ON         OFF            ON        OFF

LED4 (400): ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄▄▄
            └───────────────┬───────────────┘ └───────────────┬───
                           ON            OFF                 ON

LED5 (500): ▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▀▀▀▀▀▀▀▀▀▀▀▀
            └─────────────────────┬─────────────────────┘
                                 ON                  OFF

Период = ON время + OFF время
LED1: 100мс ON + 100мс OFF = 200мс полный цикл
LED2: 200мс ON + 200мс OFF = 400мс полный цикл
LED3: 300мс ON + 300мс OFF = 600мс полный цикл
LED4: 400мс ON + 400мс OFF = 800мс полный цикл
LED5: 500мс ON + 500мс OFF = 1000мс полный цикл
```

## 4. Реализация

### 4.1 Конфигурация регистров Timer1

```cpp
// Режим CTC: WGM12=1, WGM13=0, WGM11=0, WGM10=0
TCCR1B |= (1 << WGM12);

// Prescaler 256: CS12=1, CS11=0, CS10=0
TCCR1B |= (1 << CS12);

// Значение сравнения
OCR1A = 6249;

// Разрешение прерывания по совпадению
TIMSK1 |= (1 << OCIE1A);
```

### 4.2 Настройка портов ввода-вывода

```cpp
// Установка PB0-PB4 как выходов
DDRB |= (1 << PB0) | (1 << PB1) | (1 << PB2) |
        (1 << PB3) | (1 << PB4);

// Начальное состояние: все светодиоды включены
PORTB |= (1 << PB0) | (1 << PB1) | (1 << PB2) |
         (1 << PB3) | (1 << PB4);
```

### 4.3 Обработчик прерывания

```cpp
ISR(TIMER1_COMPA_vect) {
  // Инкремент счётчиков
  counter1++; counter2++; counter3++; counter4++; counter5++;

  // Проверка и управление каждым LED
  // LED включен в первой половине цикла (0 до PERIOD)
  // LED выключен во второй половине (PERIOD до PERIOD*2)
  if (counter1 < LED1_PERIOD) {
    PORTB |= (1 << LED1_PIN);   // Включить LED
  } else if (counter1 < LED1_PERIOD * 2) {
    PORTB &= ~(1 << LED1_PIN);  // Выключить LED
  } else {
    counter1 = 0;  // Сброс счётчика после полного цикла
  }
  // ... аналогично для LED2-LED5

  // Устанавливаем флаг для отправки данных в Serial
  send_plot_data = true;
}
```

### 4.4 Функция вывода в Serial Plotter

```cpp
void loop() {
  if (PLOT_ENABLED && send_plot_data) {
    send_plot_data = false;

    // Чтение состояния каждого LED через побитовую операцию AND
    uint8_t led1_state = (PORTB & (1 << LED1_PIN)) ? 1 : 0;
    uint8_t led2_state = (PORTB & (1 << LED2_PIN)) ? 2 : 0;
    // ... для остальных LED

    // Вывод в формате CSV для Serial Plotter
    Serial.print("LED1:");
    Serial.print(led1_state);
    Serial.print(",LED2:");
    Serial.print(led2_state);
    // ... для остальных LED
    Serial.println(led5_state);
  }
}
```

### 4.5 Побитовые операции

**Операция XOR (^) для инверсии:**

```
Текущее состояние: PORTB = 0b00010101
Маска:                     0b00000001 (1 << PB0)
Результат XOR:    PORTB = 0b00010100
```

**Операция OR (|) для установки битов:**

```
DDRB |= (1 << PB0);  // Устанавливает бит PB0 в 1
```

**Операция AND (&) для сброса битов:**

```
PORTB &= ~(1 << PB0);  // Устанавливает бит PB0 в 0
```

## 5. Анализ производительности

### 5.1 Точность временных интервалов

**Погрешность таймера:**

- Теоретическая точность: 1 такт процессора = 62.5 нс
- Джиттер прерывания: ±4 такта (±250 нс)
- Относительная погрешность: 250 нс / 100 мс = 0.00025%

### 5.2 Загрузка процессора

**Время выполнения ISR:** ~20 тактов × 5 LED = ~100 тактов = 6.25 мкс

**Частота прерываний:** 10 Гц (каждые 100 мс)

**Загрузка CPU:**

```
Загрузка = (6.25 мкс × 10 Гц) / 1 с × 100% = 0.00625%
```

### 5.3 Период повторения паттерна

Наименьшее общее кратное (НОК) полных циклов (период\*2):

```
Полные циклы: LED1=2, LED2=4, LED3=6, LED4=8, LED5=10 интервалов
НОК(2,4,6,8,10) = 120 интервалов = 12000 мс = 12 секунд
```

Полный паттерн всех светодиодов повторяется каждые 12 секунд.

## 6. Схема подключения

```
Arduino Uno         Резисторы      Светодиоды

PB0 (D8)  ────────┤ 220Ω ├──────►|─── GND (LED1)

PB1 (D9)  ────────┤ 220Ω ├──────►|─── GND (LED2)

PB2 (D10) ────────┤ 220Ω ├──────►|─── GND (LED3)

PB3 (D11) ────────┤ 220Ω ├──────►|─── GND (LED4)

PB4 (D12) ────────┤ 220Ω ├──────►|─── GND (LED5)
```

**Примечания:**

- Резисторы 220 Ом ограничивают ток через светодиоды
- Ток светодиода: I = (5V - 2V) / 220Ω ≈ 13.6 мА
- Катоды всех светодиодов подключены к GND

[Схема в Tinkercad](https://www.tinkercad.com/things/csLpEHHw8as-shiny-albar-inari?sharecode=fY9RtjR6-e1s4_Y_8NR8vAGlZDHJYCgbB1-LhZAJk0A)
